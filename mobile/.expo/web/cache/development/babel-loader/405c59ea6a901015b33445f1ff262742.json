{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { EventEmitter } from '@unimodules/core';\n\nvar GeocoderError = function (_Error) {\n  _inherits(GeocoderError, _Error);\n\n  var _super = _createSuper(GeocoderError);\n\n  function GeocoderError() {\n    var _this;\n\n    _classCallCheck(this, GeocoderError);\n\n    _this = _super.call(this, 'Geocoder service is not available for this device.');\n    _this.code = 'E_NO_GEOCODER';\n    return _this;\n  }\n\n  return GeocoderError;\n}(_wrapNativeSuper(Error));\n\nvar emitter = new EventEmitter({});\n\nfunction positionToJSON(position) {\n  if (!position) return null;\n  var _position$coords = position.coords,\n      coords = _position$coords === void 0 ? {} : _position$coords,\n      timestamp = position.timestamp;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed\n    },\n    timestamp: timestamp\n  };\n}\n\nexport default {\n  get name() {\n    return 'ExpoLocation';\n  },\n\n  getProviderStatusAsync: function getProviderStatusAsync() {\n    return _regeneratorRuntime.async(function getProviderStatusAsync$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", {\n              locationServicesEnabled: 'geolocation' in navigator\n            });\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getCurrentPositionAsync: function getCurrentPositionAsync(options) {\n    return _regeneratorRuntime.async(function getCurrentPositionAsync$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n              return navigator.geolocation.getCurrentPosition(function (position) {\n                return resolve(positionToJSON(position));\n              }, reject, options);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  removeWatchAsync: function removeWatchAsync(watchId) {\n    return _regeneratorRuntime.async(function removeWatchAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            navigator.geolocation.clearWatch(watchId);\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  watchDeviceHeading: function watchDeviceHeading(headingId) {\n    return _regeneratorRuntime.async(function watchDeviceHeading$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            console.warn('Location.watchDeviceHeading: is not supported on web');\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  hasServicesEnabledAsync: function hasServicesEnabledAsync() {\n    return _regeneratorRuntime.async(function hasServicesEnabledAsync$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            return _context5.abrupt(\"return\", 'geolocation' in navigator);\n\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  geocodeAsync: function geocodeAsync() {\n    return _regeneratorRuntime.async(function geocodeAsync$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            throw new GeocoderError();\n\n          case 1:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  reverseGeocodeAsync: function reverseGeocodeAsync() {\n    return _regeneratorRuntime.async(function reverseGeocodeAsync$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            throw new GeocoderError();\n\n          case 1:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  watchPositionImplAsync: function watchPositionImplAsync(watchId, options) {\n    return _regeneratorRuntime.async(function watchPositionImplAsync$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", new Promise(function (resolve) {\n              watchId = global.navigator.geolocation.watchPosition(function (location) {\n                emitter.emit('Expo.locationChanged', {\n                  watchId: watchId,\n                  location: positionToJSON(location)\n                });\n              }, null, options);\n              resolve(watchId);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  requestPermissionsAsync: function requestPermissionsAsync() {\n    return _regeneratorRuntime.async(function requestPermissionsAsync$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            return _context9.abrupt(\"return\", new Promise(function (resolve) {\n              navigator.geolocation.getCurrentPosition(function () {\n                return resolve({\n                  status: 'granted'\n                });\n              }, function (_ref) {\n                var code = _ref.code;\n\n                if (code === 1) {\n                    resolve({\n                      status: 'denied'\n                    });\n                  } else {\n                  resolve({\n                    status: 'undetermined'\n                  });\n                }\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};","map":{"version":3,"sources":["../src/ExpoLocation.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from '@unimodules/core';\n\ninterface Coordinates {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n  altitudeAccuracy?: number;\n  heading?: number;\n  speed?: number;\n}\n\ninterface Position {\n  coords: Coordinates;\n  timestamp: number;\n}\n\ninterface PermissionResult {\n  status: string;\n}\n\nclass GeocoderError extends Error {\n  code: string;\n\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\n\nconst emitter = new EventEmitter({} as any);\n\nfunction positionToJSON(position: any): Position | null {\n  if (!position) return null;\n\n  const { coords = {}, timestamp } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed,\n    },\n    timestamp,\n  };\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoLocation';\n  },\n  async getProviderStatusAsync(): Promise<{ locationServicesEnabled: boolean }> {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator,\n    };\n  },\n  async getCurrentPositionAsync(options: object): Promise<Position | null> {\n    return new Promise<Position | null>((resolve, reject) =>\n      navigator.geolocation.getCurrentPosition(\n        position => resolve(positionToJSON(position)),\n        reject,\n        options\n      )\n    );\n  },\n  async removeWatchAsync(watchId): Promise<void> {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId): Promise<void> {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync(): Promise<boolean> {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId: string, options: object): Promise<string> {\n    return new Promise<string>(resolve => {\n      // @ts-ignore\n      watchId = global.navigator.geolocation.watchPosition(\n        location => {\n          emitter.emit('Expo.locationChanged', { watchId, location: positionToJSON(location) });\n        },\n        null,\n        options\n      );\n      resolve(watchId);\n    });\n  },\n  async requestPermissionsAsync(): Promise<PermissionResult> {\n    return new Promise<PermissionResult>(resolve => {\n      navigator.geolocation.getCurrentPosition(\n        () => resolve({ status: 'granted' }),\n        ({ code }) => {\n          if (code === 1 /* PERMISSION_DENIED */) {\n            resolve({ status: 'denied' });\n          } else {\n            resolve({ status: 'undetermined' });\n          }\n        }\n      );\n    });\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}