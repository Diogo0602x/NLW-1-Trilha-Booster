{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { EventEmitter, Platform, CodedError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport { PermissionStatus } from 'unimodules-permissions-interface';\nimport ExpoLocation from \"./ExpoLocation\";\nvar LocationEventEmitter = new EventEmitter(ExpoLocation);\nexport { PermissionStatus };\nvar LocationAccuracy;\n\n(function (LocationAccuracy) {\n  LocationAccuracy[LocationAccuracy[\"Lowest\"] = 1] = \"Lowest\";\n  LocationAccuracy[LocationAccuracy[\"Low\"] = 2] = \"Low\";\n  LocationAccuracy[LocationAccuracy[\"Balanced\"] = 3] = \"Balanced\";\n  LocationAccuracy[LocationAccuracy[\"High\"] = 4] = \"High\";\n  LocationAccuracy[LocationAccuracy[\"Highest\"] = 5] = \"Highest\";\n  LocationAccuracy[LocationAccuracy[\"BestForNavigation\"] = 6] = \"BestForNavigation\";\n})(LocationAccuracy || (LocationAccuracy = {}));\n\nvar LocationActivityType;\n\n(function (LocationActivityType) {\n  LocationActivityType[LocationActivityType[\"Other\"] = 1] = \"Other\";\n  LocationActivityType[LocationActivityType[\"AutomotiveNavigation\"] = 2] = \"AutomotiveNavigation\";\n  LocationActivityType[LocationActivityType[\"Fitness\"] = 3] = \"Fitness\";\n  LocationActivityType[LocationActivityType[\"OtherNavigation\"] = 4] = \"OtherNavigation\";\n  LocationActivityType[LocationActivityType[\"Airborne\"] = 5] = \"Airborne\";\n})(LocationActivityType || (LocationActivityType = {}));\n\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType };\nexport var GeofencingEventType;\n\n(function (GeofencingEventType) {\n  GeofencingEventType[GeofencingEventType[\"Enter\"] = 1] = \"Enter\";\n  GeofencingEventType[GeofencingEventType[\"Exit\"] = 2] = \"Exit\";\n})(GeofencingEventType || (GeofencingEventType = {}));\n\nexport var GeofencingRegionState;\n\n(function (GeofencingRegionState) {\n  GeofencingRegionState[GeofencingRegionState[\"Unknown\"] = 0] = \"Unknown\";\n  GeofencingRegionState[GeofencingRegionState[\"Inside\"] = 1] = \"Inside\";\n  GeofencingRegionState[GeofencingRegionState[\"Outside\"] = 2] = \"Outside\";\n})(GeofencingRegionState || (GeofencingRegionState = {}));\n\nvar nextWatchId = 0;\nvar headingId;\n\nfunction _getNextWatchId() {\n  nextWatchId++;\n  return nextWatchId;\n}\n\nfunction _getCurrentWatchId() {\n  return nextWatchId;\n}\n\nvar watchCallbacks = {};\nvar deviceEventSubscription;\nvar headingEventSub;\nvar googleApiKey;\nvar googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\nexport function getProviderStatusAsync() {\n  return _regeneratorRuntime.async(function getProviderStatusAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", ExpoLocation.getProviderStatusAsync());\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function enableNetworkProviderAsync() {\n  return _regeneratorRuntime.async(function enableNetworkProviderAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(Platform.OS === 'android')) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", ExpoLocation.enableNetworkProviderAsync());\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getCurrentPositionAsync() {\n  var options,\n      _args3 = arguments;\n  return _regeneratorRuntime.async(function getCurrentPositionAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n          return _context3.abrupt(\"return\", ExpoLocation.getCurrentPositionAsync(options));\n\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getLastKnownPositionAsync() {\n  return _regeneratorRuntime.async(function getLastKnownPositionAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.abrupt(\"return\", ExpoLocation.getLastKnownPositionAsync());\n\n        case 1:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getHeadingAsync() {\n  return _regeneratorRuntime.async(function getHeadingAsync$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          return _context6.abrupt(\"return\", new Promise(function _callee(resolve, reject) {\n            var tries, headingSub, done, subscription, _tries;\n\n            return _regeneratorRuntime.async(function _callee$(_context5) {\n              while (1) {\n                switch (_context5.prev = _context5.next) {\n                  case 0:\n                    _context5.prev = 0;\n\n                    if (!headingEventSub) {\n                      _context5.next = 6;\n                      break;\n                    }\n\n                    tries = 0;\n                    headingSub = LocationEventEmitter.addListener('Expo.headingChanged', function (_ref) {\n                      var heading = _ref.heading;\n\n                      if (heading.accuracy > 1 || tries > 5) {\n                        resolve(heading);\n                        LocationEventEmitter.removeSubscription(headingSub);\n                      } else {\n                        tries += 1;\n                      }\n                    });\n                    _context5.next = 12;\n                    break;\n\n                  case 6:\n                    done = false;\n                    _tries = 0;\n                    _context5.next = 10;\n                    return _regeneratorRuntime.awrap(watchHeadingAsync(function (heading) {\n                      if (!done) {\n                        if (heading.accuracy > 1 || _tries > 5) {\n                          subscription.remove();\n                          resolve(heading);\n                          done = true;\n                        } else {\n                          _tries += 1;\n                        }\n                      } else {\n                        subscription.remove();\n                      }\n                    }));\n\n                  case 10:\n                    subscription = _context5.sent;\n\n                    if (done) {\n                      subscription.remove();\n                    }\n\n                  case 12:\n                    _context5.next = 17;\n                    break;\n\n                  case 14:\n                    _context5.prev = 14;\n                    _context5.t0 = _context5[\"catch\"](0);\n                    reject(_context5.t0);\n\n                  case 17:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }\n            }, null, null, [[0, 14]], Promise);\n          }));\n\n        case 1:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function watchHeadingAsync(callback) {\n  return _regeneratorRuntime.async(function watchHeadingAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          if (headingEventSub) {\n            _removeHeadingWatcher(headingId);\n          }\n\n          headingEventSub = LocationEventEmitter.addListener('Expo.headingChanged', function (_ref2) {\n            var watchId = _ref2.watchId,\n                heading = _ref2.heading;\n            var callback = watchCallbacks[watchId];\n\n            if (callback) {\n              callback(heading);\n            } else {\n              ExpoLocation.removeWatchAsync(watchId);\n            }\n          });\n          headingId = _getNextWatchId();\n          watchCallbacks[headingId] = callback;\n          _context7.next = 6;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchDeviceHeading(headingId));\n\n        case 6:\n          return _context7.abrupt(\"return\", {\n            remove: function remove() {\n              _removeHeadingWatcher(headingId);\n            }\n          });\n\n        case 7:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _removeHeadingWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n\n  delete watchCallbacks[watchId];\n  ExpoLocation.removeWatchAsync(watchId);\n\n  if (headingEventSub) {\n    LocationEventEmitter.removeSubscription(headingEventSub);\n    headingEventSub = null;\n  }\n}\n\nfunction _maybeInitializeEmitterSubscription() {\n  if (!deviceEventSubscription) {\n    deviceEventSubscription = LocationEventEmitter.addListener('Expo.locationChanged', function (_ref3) {\n      var watchId = _ref3.watchId,\n          location = _ref3.location;\n      var callback = watchCallbacks[watchId];\n\n      if (callback) {\n        callback(location);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    });\n  }\n}\n\nexport function geocodeAsync(address) {\n  return _regeneratorRuntime.async(function geocodeAsync$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          return _context8.abrupt(\"return\", ExpoLocation.geocodeAsync(address).catch(function (error) {\n            var platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n            if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n              if (!googleApiKey) {\n                throw new CodedError(error.code, error.message + \" Please set a Google API Key to use geocoding.\");\n              }\n\n              return _googleGeocodeAsync(address);\n            }\n\n            throw error;\n          }));\n\n        case 1:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function reverseGeocodeAsync(location) {\n  return _regeneratorRuntime.async(function reverseGeocodeAsync$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          if (!(typeof location.latitude !== 'number' || typeof location.longitude !== 'number')) {\n            _context9.next = 2;\n            break;\n          }\n\n          throw new TypeError('Location should be an object with number properties `latitude` and `longitude`.');\n\n        case 2:\n          return _context9.abrupt(\"return\", ExpoLocation.reverseGeocodeAsync(location).catch(function (error) {\n            var platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n            if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n              if (!googleApiKey) {\n                throw new CodedError(error.code, error.message + \" Please set a Google API Key to use geocoding.\");\n              }\n\n              return _googleReverseGeocodeAsync(location);\n            }\n\n            throw error;\n          }));\n\n        case 3:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setApiKey(apiKey) {\n  googleApiKey = apiKey;\n}\n\nfunction _googleGeocodeAsync(address) {\n  var result, resultObject;\n  return _regeneratorRuntime.async(function _googleGeocodeAsync$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          _context10.next = 2;\n          return _regeneratorRuntime.awrap(fetch(googleApiUrl + \"?key=\" + googleApiKey + \"&address=\" + encodeURI(address)));\n\n        case 2:\n          result = _context10.sent;\n          _context10.next = 5;\n          return _regeneratorRuntime.awrap(result.json());\n\n        case 5:\n          resultObject = _context10.sent;\n\n          if (!(resultObject.status === 'ZERO_RESULTS')) {\n            _context10.next = 8;\n            break;\n          }\n\n          return _context10.abrupt(\"return\", []);\n\n        case 8:\n          assertGeocodeResults(resultObject);\n          return _context10.abrupt(\"return\", resultObject.results.map(function (result) {\n            var location = result.geometry.location;\n            return {\n              latitude: location.lat,\n              longitude: location.lng\n            };\n          }));\n\n        case 10:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _googleReverseGeocodeAsync(options) {\n  var result, resultObject;\n  return _regeneratorRuntime.async(function _googleReverseGeocodeAsync$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          _context11.next = 2;\n          return _regeneratorRuntime.awrap(fetch(googleApiUrl + \"?key=\" + googleApiKey + \"&latlng=\" + options.latitude + \",\" + options.longitude));\n\n        case 2:\n          result = _context11.sent;\n          _context11.next = 5;\n          return _regeneratorRuntime.awrap(result.json());\n\n        case 5:\n          resultObject = _context11.sent;\n\n          if (!(resultObject.status === 'ZERO_RESULTS')) {\n            _context11.next = 8;\n            break;\n          }\n\n          return _context11.abrupt(\"return\", []);\n\n        case 8:\n          assertGeocodeResults(resultObject);\n          return _context11.abrupt(\"return\", resultObject.results.map(function (result) {\n            var address = {};\n            result.address_components.forEach(function (component) {\n              if (component.types.includes('locality')) {\n                address.city = component.long_name;\n              } else if (component.types.includes('street_address')) {\n                address.street = component.long_name;\n              } else if (component.types.includes('administrative_area_level_1')) {\n                address.region = component.long_name;\n              } else if (component.types.includes('country')) {\n                address.country = component.long_name;\n              } else if (component.types.includes('postal_code')) {\n                address.postalCode = component.long_name;\n              } else if (component.types.includes('point_of_interest')) {\n                address.name = component.long_name;\n              }\n            });\n            return address;\n          }));\n\n        case 10:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction assertGeocodeResults(resultObject) {\n  var status = resultObject.status,\n      error_message = resultObject.error_message;\n\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(status, 'the request could not be processed due to a server error. The request may succeed if you try again.');\n    }\n\n    throw new CodedError(status, \"An error occurred during geocoding.\");\n  }\n}\n\nfunction watchPosition(success, error, options) {\n  _maybeInitializeEmitterSubscription();\n\n  var watchId = _getNextWatchId();\n\n  watchCallbacks[watchId] = success;\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch(function (err) {\n    _removeWatcher(watchId);\n\n    error({\n      watchId: watchId,\n      message: err.message,\n      code: err.code\n    });\n  });\n  return watchId;\n}\n\nexport function watchPositionAsync(options, callback) {\n  var watchId;\n  return _regeneratorRuntime.async(function watchPositionAsync$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          _maybeInitializeEmitterSubscription();\n\n          watchId = _getNextWatchId();\n          watchCallbacks[watchId] = callback;\n          _context12.next = 5;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchPositionImplAsync(watchId, options));\n\n        case 5:\n          return _context12.abrupt(\"return\", {\n            remove: function remove() {\n              _removeWatcher(watchId);\n            }\n          });\n\n        case 6:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction clearWatch(watchId) {\n  _removeWatcher(watchId);\n}\n\nfunction _removeWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n\n  ExpoLocation.removeWatchAsync(watchId);\n  delete watchCallbacks[watchId];\n\n  if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n    LocationEventEmitter.removeSubscription(deviceEventSubscription);\n    deviceEventSubscription = null;\n  }\n}\n\nfunction getCurrentPosition(success) {\n  var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  invariant(typeof success === 'function', 'Must provide a valid success callback.');\n  invariant(typeof options === 'object', 'options must be an object.');\n\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\n\nfunction _getCurrentPositionAsyncWrapper(success, error, options) {\n  var result;\n  return _regeneratorRuntime.async(function _getCurrentPositionAsyncWrapper$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          _context13.prev = 0;\n          _context13.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestPermissionsAsync());\n\n        case 3:\n          _context13.next = 5;\n          return _regeneratorRuntime.awrap(getCurrentPositionAsync(options));\n\n        case 5:\n          result = _context13.sent;\n          success(result);\n          _context13.next = 12;\n          break;\n\n        case 9:\n          _context13.prev = 9;\n          _context13.t0 = _context13[\"catch\"](0);\n          error(_context13.t0);\n\n        case 12:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, null, null, [[0, 9]], Promise);\n}\n\nexport function getPermissionsAsync() {\n  return _regeneratorRuntime.async(function getPermissionsAsync$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          _context14.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.getPermissionsAsync());\n\n        case 2:\n          return _context14.abrupt(\"return\", _context14.sent);\n\n        case 3:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestPermissionsAsync$(_context15) {\n    while (1) {\n      switch (_context15.prev = _context15.next) {\n        case 0:\n          _context15.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestPermissionsAsync());\n\n        case 2:\n          return _context15.abrupt(\"return\", _context15.sent);\n\n        case 3:\n        case \"end\":\n          return _context15.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasServicesEnabledAsync() {\n  return _regeneratorRuntime.async(function hasServicesEnabledAsync$(_context16) {\n    while (1) {\n      switch (_context16.prev = _context16.next) {\n        case 0:\n          _context16.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.hasServicesEnabledAsync());\n\n        case 2:\n          return _context16.abrupt(\"return\", _context16.sent);\n\n        case 3:\n        case \"end\":\n          return _context16.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _validateTaskName(taskName) {\n  invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\n\nexport function isBackgroundLocationAvailableAsync() {\n  var providerStatus;\n  return _regeneratorRuntime.async(function isBackgroundLocationAvailableAsync$(_context17) {\n    while (1) {\n      switch (_context17.prev = _context17.next) {\n        case 0:\n          _context17.next = 2;\n          return _regeneratorRuntime.awrap(getProviderStatusAsync());\n\n        case 2:\n          providerStatus = _context17.sent;\n          return _context17.abrupt(\"return\", providerStatus.backgroundModeEnabled);\n\n        case 4:\n        case \"end\":\n          return _context17.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function startLocationUpdatesAsync(taskName) {\n  var options,\n      _args18 = arguments;\n  return _regeneratorRuntime.async(function startLocationUpdatesAsync$(_context18) {\n    while (1) {\n      switch (_context18.prev = _context18.next) {\n        case 0:\n          options = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : {\n            accuracy: LocationAccuracy.Balanced\n          };\n\n          _validateTaskName(taskName);\n\n          _context18.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocation.startLocationUpdatesAsync(taskName, options));\n\n        case 4:\n        case \"end\":\n          return _context18.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function stopLocationUpdatesAsync$(_context19) {\n    while (1) {\n      switch (_context19.prev = _context19.next) {\n        case 0:\n          _validateTaskName(taskName);\n\n          _context19.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopLocationUpdatesAsync(taskName));\n\n        case 3:\n        case \"end\":\n          return _context19.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedLocationUpdatesAsync$(_context20) {\n    while (1) {\n      switch (_context20.prev = _context20.next) {\n        case 0:\n          _validateTaskName(taskName);\n\n          return _context20.abrupt(\"return\", ExpoLocation.hasStartedLocationUpdatesAsync(taskName));\n\n        case 2:\n        case \"end\":\n          return _context20.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n\n  for (var _iterator = _createForOfIteratorHelperLoose(regions), _step; !(_step = _iterator()).done;) {\n    var region = _step.value;\n\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(\"Region's latitude must be a number. Got '\" + region.latitude + \"' instead.\");\n    }\n\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\"Region's longitude must be a number. Got '\" + region.longitude + \"' instead.\");\n    }\n\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(\"Region's radius must be a number. Got '\" + region.radius + \"' instead.\");\n    }\n  }\n}\n\nexport function startGeofencingAsync(taskName) {\n  var regions,\n      _args21 = arguments;\n  return _regeneratorRuntime.async(function startGeofencingAsync$(_context21) {\n    while (1) {\n      switch (_context21.prev = _context21.next) {\n        case 0:\n          regions = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : [];\n\n          _validateTaskName(taskName);\n\n          _validateRegions(regions);\n\n          _context21.next = 5;\n          return _regeneratorRuntime.awrap(ExpoLocation.startGeofencingAsync(taskName, {\n            regions: regions\n          }));\n\n        case 5:\n        case \"end\":\n          return _context21.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function stopGeofencingAsync$(_context22) {\n    while (1) {\n      switch (_context22.prev = _context22.next) {\n        case 0:\n          _validateTaskName(taskName);\n\n          _context22.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopGeofencingAsync(taskName));\n\n        case 3:\n        case \"end\":\n          return _context22.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedGeofencingAsync$(_context23) {\n    while (1) {\n      switch (_context23.prev = _context23.next) {\n        case 0:\n          _validateTaskName(taskName);\n\n          return _context23.abrupt(\"return\", ExpoLocation.hasStartedGeofencingAsync(taskName));\n\n        case 2:\n        case \"end\":\n          return _context23.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function installWebGeolocationPolyfill() {\n  if (Platform.OS !== 'web') {\n    window.navigator.geolocation = {\n      getCurrentPosition: getCurrentPosition,\n      watchPosition: watchPosition,\n      clearWatch: clearWatch,\n      stopObserving: function stopObserving() {}\n    };\n  }\n}\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };","map":{"version":3,"sources":["../src/Location.ts"],"names":[],"mappings":";;;;;;;AAAA,SAAS,YAAT,EAAuB,QAAvB,EAAiC,UAAjC,QAAmD,kBAAnD;AACA,OAAO,SAAP,MAAsB,WAAtB;AACA,SAEE,gBAFF,QAGO,kCAHP;AAKA,OAAO,YAAP;AAEA,IAAM,oBAAoB,GAAG,IAAI,YAAJ,CAAiB,YAAjB,CAA7B;AAsDA,SAAS,gBAAT;AAkDA,IAAK,gBAAL;;AAAA,CAAA,UAAK,gBAAL,EAAqB;AACnB,EAAA,gBAAA,CAAA,gBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,gBAAA,CAAA,gBAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,GAAA,KAAA;AACA,EAAA,gBAAA,CAAA,gBAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,EAAA,gBAAA,CAAA,gBAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACA,EAAA,gBAAA,CAAA,gBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,gBAAA,CAAA,gBAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,mBAAA;AACD,CAPD,EAAK,gBAAgB,KAAhB,gBAAgB,GAAA,EAAA,CAArB;;AASA,IAAK,oBAAL;;AAAA,CAAA,UAAK,oBAAL,EAAyB;AACvB,EAAA,oBAAA,CAAA,oBAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACA,EAAA,oBAAA,CAAA,oBAAA,CAAA,sBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,sBAAA;AACA,EAAA,oBAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,oBAAA,CAAA,oBAAA,CAAA,iBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,iBAAA;AACA,EAAA,oBAAA,CAAA,oBAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACD,CAND,EAAK,oBAAoB,KAApB,oBAAoB,GAAA,EAAA,CAAzB;;AAQA,SAAS,gBAAgB,IAAI,QAA7B,EAAuC,oBAAoB,IAAI,YAA/D;AAEA,OAAA,IAAY,mBAAZ;;AAAA,CAAA,UAAY,mBAAZ,EAA+B;AAC7B,EAAA,mBAAA,CAAA,mBAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACA,EAAA,mBAAA,CAAA,mBAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACD,CAHD,EAAY,mBAAmB,KAAnB,mBAAmB,GAAA,EAAA,CAA/B;;AAKA,OAAA,IAAY,qBAAZ;;AAAA,CAAA,UAAY,qBAAZ,EAAiC;AAC/B,EAAA,qBAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACD,CAJD,EAAY,qBAAqB,KAArB,qBAAqB,GAAA,EAAA,CAAjC;;AAMA,IAAI,WAAW,GAAG,CAAlB;AACA,IAAI,SAAJ;;AACA,SAAS,eAAT,GAAwB;AACtB,EAAA,WAAW;AACX,SAAO,WAAP;AACD;;AACD,SAAS,kBAAT,GAA2B;AACzB,SAAO,WAAP;AACD;;AAED,IAAI,cAAc,GAEd,EAFJ;AAIA,IAAI,uBAAJ;AACA,IAAI,eAAJ;AACA,IAAI,YAAJ;AACA,IAAM,YAAY,GAAG,mDAArB;AAEA,OAAO,SAAe,sBAAf;AAAA;AAAA;AAAA;AAAA;AAAA,2CACE,YAAY,CAAC,sBAAb,EADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIP,OAAO,SAAe,0BAAf;AAAA;AAAA;AAAA;AAAA;AAAA,gBAMD,QAAQ,CAAC,EAAT,KAAgB,SANf;AAAA;AAAA;AAAA;;AAAA,4CAOI,YAAY,CAAC,0BAAb,EAPJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWP,OAAO,SAAe,uBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,OADK,8DACsB,EADtB;AAAA,4CAGE,YAAY,CAAC,uBAAb,CAAqC,OAArC,CAHF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMP,OAAO,SAAe,yBAAf;AAAA;AAAA;AAAA;AAAA;AAAA,4CACE,YAAY,CAAC,yBAAb,EADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQP,OAAO,SAAe,eAAf;AAAA;AAAA;AAAA;AAAA;AAAA,4CACE,IAAI,OAAJ,CAAyB,iBAAO,OAAP,EAAgB,MAAhB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,yBAGxB,eAHwB;AAAA;AAAA;AAAA;;AAItB,oBAAA,KAJsB,GAId,CAJc;AAKpB,oBAAA,UALoB,GAKP,oBAAoB,CAAC,WAArB,CACjB,qBADiB,EAEjB,gBAA0C;AAAA,0BAAvC,OAAuC,QAAvC,OAAuC;;AACxC,0BAAI,OAAO,CAAC,QAAR,GAAmB,CAAnB,IAAwB,KAAK,GAAG,CAApC,EAAuC;AACrC,wBAAA,OAAO,CAAC,OAAD,CAAP;AACA,wBAAA,oBAAoB,CAAC,kBAArB,CAAwC,UAAxC;AACD,uBAHD,MAGO;AACL,wBAAA,KAAK,IAAI,CAAT;AACD;AACF,qBATgB,CALO;AAAA;AAAA;;AAAA;AAiBtB,oBAAA,IAjBsB,GAiBf,KAjBe;AAmBtB,oBAAA,MAnBsB,GAmBd,CAnBc;AAAA;AAAA,qDAoBL,iBAAiB,CAAC,UAAC,OAAD,EAAyB;AAC9D,0BAAI,CAAC,IAAL,EAAW;AACT,4BAAI,OAAO,CAAC,QAAR,GAAmB,CAAnB,IAAwB,MAAK,GAAG,CAApC,EAAuC;AACrC,0BAAA,YAAY,CAAC,MAAb;AACA,0BAAA,OAAO,CAAC,OAAD,CAAP;AACA,0BAAA,IAAI,GAAG,IAAP;AACD,yBAJD,MAIO;AACL,0BAAA,MAAK,IAAI,CAAT;AACD;AACF,uBARD,MAQO;AACL,wBAAA,YAAY,CAAC,MAAb;AACD;AACF,qBAZqC,CApBZ;;AAAA;AAoB1B,oBAAA,YApB0B;;AAkC1B,wBAAI,IAAJ,EAAU;AACR,sBAAA,YAAY,CAAC,MAAb;AACD;;AApCyB;AAAA;AAAA;;AAAA;AAAA;AAAA;AAuC5B,oBAAA,MAAM,cAAN;;AAvC4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAzB,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6CP,OAAO,SAAe,iBAAf,CACL,QADK;AAAA;AAAA;AAAA;AAAA;AAIL,cAAI,eAAJ,EAAqB;AACnB,YAAA,qBAAqB,CAAC,SAAD,CAArB;AACD;;AAED,UAAA,eAAe,GAAG,oBAAoB,CAAC,WAArB,CAChB,qBADgB,EAEhB,iBAAoE;AAAA,gBAAjE,OAAiE,SAAjE,OAAiE;AAAA,gBAAxD,OAAwD,SAAxD,OAAwD;AAClE,gBAAM,QAAQ,GAAG,cAAc,CAAC,OAAD,CAA/B;;AACA,gBAAI,QAAJ,EAAc;AACZ,cAAA,QAAQ,CAAC,OAAD,CAAR;AACD,aAFD,MAEO;AACL,cAAA,YAAY,CAAC,gBAAb,CAA8B,OAA9B;AACD;AACF,WATe,CAAlB;AAYA,UAAA,SAAS,GAAG,eAAe,EAA3B;AACA,UAAA,cAAc,CAAC,SAAD,CAAd,GAA4B,QAA5B;AArBK;AAAA,2CAsBC,YAAY,CAAC,kBAAb,CAAgC,SAAhC,CAtBD;;AAAA;AAAA,4CAuBE;AACL,YAAA,MADK,oBACC;AACJ,cAAA,qBAAqB,CAAC,SAAD,CAArB;AACD;AAHI,WAvBF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+BP,SAAS,qBAAT,CAA+B,OAA/B,EAAsC;AACpC,MAAI,CAAC,cAAc,CAAC,OAAD,CAAnB,EAA8B;AAC5B;AACD;;AACD,SAAO,cAAc,CAAC,OAAD,CAArB;AACA,EAAA,YAAY,CAAC,gBAAb,CAA8B,OAA9B;;AACA,MAAI,eAAJ,EAAqB;AACnB,IAAA,oBAAoB,CAAC,kBAArB,CAAwC,eAAxC;AACA,IAAA,eAAe,GAAG,IAAlB;AACD;AACF;;AAGD,SAAS,mCAAT,GAA4C;AAC1C,MAAI,CAAC,uBAAL,EAA8B;AAC5B,IAAA,uBAAuB,GAAG,oBAAoB,CAAC,WAArB,CACxB,sBADwB,EAExB,iBAAuE;AAAA,UAApE,OAAoE,SAApE,OAAoE;AAAA,UAA3D,QAA2D,SAA3D,QAA2D;AACrE,UAAM,QAAQ,GAAG,cAAc,CAAC,OAAD,CAA/B;;AACA,UAAI,QAAJ,EAAc;AACZ,QAAA,QAAQ,CAAC,QAAD,CAAR;AACD,OAFD,MAEO;AACL,QAAA,YAAY,CAAC,gBAAb,CAA8B,OAA9B;AACD;AACF,KATuB,CAA1B;AAWD;AACF;;AAED,OAAO,SAAe,YAAf,CAA4B,OAA5B;AAAA;AAAA;AAAA;AAAA;AAAA,4CACE,YAAY,CAAC,YAAb,CAA0B,OAA1B,EAAmC,KAAnC,CAAyC,UAAA,KAAK,EAAG;AACtD,gBAAM,sBAAsB,GAAG,QAAQ,CAAC,EAAT,KAAgB,SAAhB,IAA6B,QAAQ,CAAC,EAAT,KAAgB,KAA5E;;AAEA,gBAAI,sBAAsB,IAAI,KAAK,CAAC,IAAN,KAAe,eAA7C,EAA8D;AAC5D,kBAAI,CAAC,YAAL,EAAmB;AACjB,sBAAM,IAAI,UAAJ,CACJ,KAAK,CAAC,IADF,EAED,KAAK,CAAC,OAFL,oDAAN;AAID;;AACD,qBAAO,mBAAmB,CAAC,OAAD,CAA1B;AACD;;AACD,kBAAM,KAAN;AACD,WAbM,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBP,OAAO,SAAe,mBAAf,CAAmC,QAAnC;AAAA;AAAA;AAAA;AAAA;AAAA,gBAID,OAAO,QAAQ,CAAC,QAAhB,KAA6B,QAA7B,IAAyC,OAAO,QAAQ,CAAC,SAAhB,KAA8B,QAJtE;AAAA;AAAA;AAAA;;AAAA,gBAKG,IAAI,SAAJ,CACJ,iFADI,CALH;;AAAA;AAAA,4CASE,YAAY,CAAC,mBAAb,CAAiC,QAAjC,EAA2C,KAA3C,CAAiD,UAAA,KAAK,EAAG;AAC9D,gBAAM,sBAAsB,GAAG,QAAQ,CAAC,EAAT,KAAgB,SAAhB,IAA6B,QAAQ,CAAC,EAAT,KAAgB,KAA5E;;AAEA,gBAAI,sBAAsB,IAAI,KAAK,CAAC,IAAN,KAAe,eAA7C,EAA8D;AAC5D,kBAAI,CAAC,YAAL,EAAmB;AACjB,sBAAM,IAAI,UAAJ,CACJ,KAAK,CAAC,IADF,EAED,KAAK,CAAC,OAFL,oDAAN;AAID;;AACD,qBAAO,0BAA0B,CAAC,QAAD,CAAjC;AACD;;AACD,kBAAM,KAAN;AACD,WAbM,CATF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBP,OAAM,SAAU,SAAV,CAAoB,MAApB,EAAkC;AACtC,EAAA,YAAY,GAAG,MAAf;AACD;;AAED,SAAe,mBAAf,CAAmC,OAAnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACuB,KAAK,CAAI,YAAJ,aAAwB,YAAxB,iBAAgD,SAAS,CAAC,OAAD,CAAzD,CAD5B;;AAAA;AACQ,UAAA,MADR;AAAA;AAAA,2CAE6B,MAAM,CAAC,IAAP,EAF7B;;AAAA;AAEQ,UAAA,YAFR;;AAAA,gBAIM,YAAY,CAAC,MAAb,KAAwB,cAJ9B;AAAA;AAAA;AAAA;;AAAA,6CAKW,EALX;;AAAA;AAQE,UAAA,oBAAoB,CAAC,YAAD,CAApB;AARF,6CAUS,YAAY,CAAC,OAAb,CAAqB,GAArB,CAAyB,UAAA,MAAM,EAAG;AACvC,gBAAI,QAAQ,GAAG,MAAM,CAAC,QAAP,CAAgB,QAA/B;AAEA,mBAAO;AACL,cAAA,QAAQ,EAAE,QAAQ,CAAC,GADd;AAEL,cAAA,SAAS,EAAE,QAAQ,CAAC;AAFf,aAAP;AAID,WAPM,CAVT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoBA,SAAe,0BAAf,CAA0C,OAA1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CAIuB,KAAK,CACrB,YADqB,aACD,YADC,gBACsB,OAAO,CAAC,QAD9B,SAC0C,OAAO,CAAC,SADlD,CAJ5B;;AAAA;AAIQ,UAAA,MAJR;AAAA;AAAA,2CAO6B,MAAM,CAAC,IAAP,EAP7B;;AAAA;AAOQ,UAAA,YAPR;;AAAA,gBASM,YAAY,CAAC,MAAb,KAAwB,cAT9B;AAAA;AAAA;AAAA;;AAAA,6CAUW,EAVX;;AAAA;AAaE,UAAA,oBAAoB,CAAC,YAAD,CAApB;AAbF,6CAeS,YAAY,CAAC,OAAb,CAAqB,GAArB,CAAyB,UAAA,MAAM,EAAG;AACvC,gBAAM,OAAO,GAAQ,EAArB;AAEA,YAAA,MAAM,CAAC,kBAAP,CAA0B,OAA1B,CAAkC,UAAA,SAAS,EAAG;AAC5C,kBAAI,SAAS,CAAC,KAAV,CAAgB,QAAhB,CAAyB,UAAzB,CAAJ,EAA0C;AACxC,gBAAA,OAAO,CAAC,IAAR,GAAe,SAAS,CAAC,SAAzB;AACD,eAFD,MAEO,IAAI,SAAS,CAAC,KAAV,CAAgB,QAAhB,CAAyB,gBAAzB,CAAJ,EAAgD;AACrD,gBAAA,OAAO,CAAC,MAAR,GAAiB,SAAS,CAAC,SAA3B;AACD,eAFM,MAEA,IAAI,SAAS,CAAC,KAAV,CAAgB,QAAhB,CAAyB,6BAAzB,CAAJ,EAA6D;AAClE,gBAAA,OAAO,CAAC,MAAR,GAAiB,SAAS,CAAC,SAA3B;AACD,eAFM,MAEA,IAAI,SAAS,CAAC,KAAV,CAAgB,QAAhB,CAAyB,SAAzB,CAAJ,EAAyC;AAC9C,gBAAA,OAAO,CAAC,OAAR,GAAkB,SAAS,CAAC,SAA5B;AACD,eAFM,MAEA,IAAI,SAAS,CAAC,KAAV,CAAgB,QAAhB,CAAyB,aAAzB,CAAJ,EAA6C;AAClD,gBAAA,OAAO,CAAC,UAAR,GAAqB,SAAS,CAAC,SAA/B;AACD,eAFM,MAEA,IAAI,SAAS,CAAC,KAAV,CAAgB,QAAhB,CAAyB,mBAAzB,CAAJ,EAAmD;AACxD,gBAAA,OAAO,CAAC,IAAR,GAAe,SAAS,CAAC,SAAzB;AACD;AACF,aAdD;AAeA,mBAAO,OAAP;AACD,WAnBM,CAfT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsCA,SAAS,oBAAT,CAA8B,YAA9B,EAA+C;AAAA,MACrC,MADqC,GACX,YADW,CACrC,MADqC;AAAA,MAC7B,aAD6B,GACX,YADW,CAC7B,aAD6B;;AAE7C,MAAI,MAAM,KAAK,cAAX,IAA6B,MAAM,KAAK,IAA5C,EAAkD;AAChD,QAAI,aAAJ,EAAmB;AACjB,YAAM,IAAI,UAAJ,CAAe,MAAf,EAAuB,aAAvB,CAAN;AACD,KAFD,MAEO,IAAI,MAAM,KAAK,eAAf,EAAgC;AACrC,YAAM,IAAI,UAAJ,CACJ,MADI,EAEJ,qGAFI,CAAN;AAID;;AACD,UAAM,IAAI,UAAJ,CAAe,MAAf,wCAAN;AACD;AACF;;AAGD,SAAS,aAAT,CACE,OADF,EAEE,KAFF,EAGE,OAHF,EAG0B;AAExB,EAAA,mCAAmC;;AAEnC,MAAM,OAAO,GAAG,eAAe,EAA/B;;AACA,EAAA,cAAc,CAAC,OAAD,CAAd,GAA0B,OAA1B;AAEA,EAAA,YAAY,CAAC,sBAAb,CAAoC,OAApC,EAA6C,OAA7C,EAAsD,KAAtD,CAA4D,UAAA,GAAG,EAAG;AAChE,IAAA,cAAc,CAAC,OAAD,CAAd;;AACA,IAAA,KAAK,CAAC;AAAE,MAAA,OAAO,EAAP,OAAF;AAAW,MAAA,OAAO,EAAE,GAAG,CAAC,OAAxB;AAAiC,MAAA,IAAI,EAAE,GAAG,CAAC;AAA3C,KAAD,CAAL;AACD,GAHD;AAKA,SAAO,OAAP;AACD;;AAED,OAAO,SAAe,kBAAf,CAAkC,OAAlC,EAA4D,QAA5D;AAAA;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,mCAAmC;;AAE7B,UAAA,OAHD,GAGW,eAAe,EAH1B;AAIL,UAAA,cAAc,CAAC,OAAD,CAAd,GAA0B,QAA1B;AAJK;AAAA,2CAKC,YAAY,CAAC,sBAAb,CAAoC,OAApC,EAA6C,OAA7C,CALD;;AAAA;AAAA,6CAOE;AACL,YAAA,MADK,oBACC;AACJ,cAAA,cAAc,CAAC,OAAD,CAAd;AACD;AAHI,WAPF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeP,SAAS,UAAT,CAAoB,OAApB,EAAmC;AACjC,EAAA,cAAc,CAAC,OAAD,CAAd;AACD;;AAED,SAAS,cAAT,CAAwB,OAAxB,EAA+B;AAE7B,MAAI,CAAC,cAAc,CAAC,OAAD,CAAnB,EAA8B;AAC5B;AACD;;AAED,EAAA,YAAY,CAAC,gBAAb,CAA8B,OAA9B;AACA,SAAO,cAAc,CAAC,OAAD,CAArB;;AACA,MAAI,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,MAA5B,KAAuC,CAAvC,IAA4C,uBAAhD,EAAyE;AACvE,IAAA,oBAAoB,CAAC,kBAArB,CAAwC,uBAAxC;AACA,IAAA,uBAAuB,GAAG,IAA1B;AACD;AACF;;AAKD,SAAS,kBAAT,CACE,OADF,EAG+B;AAAA,MAD7B,KAC6B,uEADH,YAAK,CAAG,CACL;AAAA,MAA7B,OAA6B,uEAAF,EAAE;AAE7B,EAAA,SAAS,CAAC,OAAO,OAAP,KAAmB,UAApB,EAAgC,wCAAhC,CAAT;AAEA,EAAA,SAAS,CAAC,OAAO,OAAP,KAAmB,QAApB,EAA8B,4BAA9B,CAAT;;AAEA,EAAA,+BAA+B,CAAC,OAAD,EAAU,KAAV,EAAiB,OAAjB,CAA/B;AACD;;AAID,SAAe,+BAAf,CACE,OADF,EAEE,KAFF,EAGE,OAHF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CAMU,YAAY,CAAC,uBAAb,EANV;;AAAA;AAAA;AAAA,2CAOyB,uBAAuB,CAAC,OAAD,CAPhD;;AAAA;AAOU,UAAA,MAPV;AAQI,UAAA,OAAO,CAAC,MAAD,CAAP;AARJ;AAAA;;AAAA;AAAA;AAAA;AAUI,UAAA,KAAK,eAAL;;AAVJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcA,OAAO,SAAe,mBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACQ,YAAY,CAAC,mBAAb,EADR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIP,OAAO,SAAe,uBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACQ,YAAY,CAAC,uBAAb,EADR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMP,OAAO,SAAe,uBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACQ,YAAY,CAAC,uBAAb,EADR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMP,SAAS,iBAAT,CAA2B,QAA3B,EAA2C;AACzC,EAAA,SAAS,CAAC,QAAQ,IAAI,OAAO,QAAP,KAAoB,QAAjC,EAA2C,wCAA3C,CAAT;AACD;;AAED,OAAO,SAAe,kCAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACwB,sBAAsB,EAD9C;;AAAA;AACC,UAAA,cADD;AAAA,6CAEE,cAAc,CAAC,qBAFjB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKP,OAAO,SAAe,yBAAf,CACL,QADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEL,UAAA,OAFK,iEAE0B;AAAE,YAAA,QAAQ,EAAE,gBAAgB,CAAC;AAA7B,WAF1B;;AAIL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AAJK;AAAA,2CAKC,YAAY,CAAC,yBAAb,CAAuC,QAAvC,EAAiD,OAAjD,CALD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQP,OAAO,SAAe,wBAAf,CAAwC,QAAxC;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AADK;AAAA,2CAEC,YAAY,CAAC,wBAAb,CAAsC,QAAtC,CAFD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKP,OAAO,SAAe,8BAAf,CAA8C,QAA9C;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AADK,6CAEE,YAAY,CAAC,8BAAb,CAA4C,QAA5C,CAFF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOP,SAAS,gBAAT,CAA0B,OAA1B,EAAmD;AACjD,MAAI,CAAC,OAAD,IAAY,OAAO,CAAC,MAAR,KAAmB,CAAnC,EAAsC;AACpC,UAAM,IAAI,KAAJ,CACJ,qGADI,CAAN;AAGD;;AACD,uDAAqB,OAArB,wCAA8B;AAAA,QAAnB,MAAmB;;AAC5B,QAAI,OAAO,MAAM,CAAC,QAAd,KAA2B,QAA/B,EAAyC;AACvC,YAAM,IAAI,SAAJ,+CAA0D,MAAM,CAAC,QAAjE,gBAAN;AACD;;AACD,QAAI,OAAO,MAAM,CAAC,SAAd,KAA4B,QAAhC,EAA0C;AACxC,YAAM,IAAI,SAAJ,gDACyC,MAAM,CAAC,SADhD,gBAAN;AAGD;;AACD,QAAI,OAAO,MAAM,CAAC,MAAd,KAAyB,QAA7B,EAAuC;AACrC,YAAM,IAAI,SAAJ,6CAAwD,MAAM,CAAC,MAA/D,gBAAN;AACD;AACF;AACF;;AAED,OAAO,SAAe,oBAAf,CACL,QADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEL,UAAA,OAFK,iEAEuB,EAFvB;;AAIL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AACA,UAAA,gBAAgB,CAAC,OAAD,CAAhB;;AALK;AAAA,2CAMC,YAAY,CAAC,oBAAb,CAAkC,QAAlC,EAA4C;AAAE,YAAA,OAAO,EAAP;AAAF,WAA5C,CAND;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASP,OAAO,SAAe,mBAAf,CAAmC,QAAnC;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AADK;AAAA,2CAEC,YAAY,CAAC,mBAAb,CAAiC,QAAjC,CAFD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKP,OAAO,SAAe,yBAAf,CAAyC,QAAzC;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AADK,6CAEE,YAAY,CAAC,yBAAb,CAAuC,QAAvC,CAFF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKP,OAAM,SAAU,6BAAV,GAAuC;AAC3C,MAAI,QAAQ,CAAC,EAAT,KAAgB,KAApB,EAA2B;AAIzB,IAAA,MAAM,CAAC,SAAP,CAAiB,WAAjB,GAA+B;AAC7B,MAAA,kBAAkB,EAAlB,kBAD6B;AAE7B,MAAA,aAAa,EAAb,aAF6B;AAG7B,MAAA,UAAU,EAAV,UAH6B;AAO7B,MAAA,aAAa,EAAE,yBAAK,CAAG;AAPM,KAA/B;AASD;AACF;AAED,SAEE,oBAAoB,IAAI,YAF1B,EAGE,kBAHF","sourcesContent":["import { EventEmitter, Platform, CodedError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport {\n  PermissionResponse as UMPermissionResponse,\n  PermissionStatus,\n} from 'unimodules-permissions-interface';\n\nimport ExpoLocation from './ExpoLocation';\n\nconst LocationEventEmitter = new EventEmitter(ExpoLocation);\n\nexport interface ProviderStatus {\n  locationServicesEnabled: boolean;\n  backgroundModeEnabled: boolean;\n  gpsAvailable?: boolean;\n  networkAvailable?: boolean;\n  passiveAvailable?: boolean;\n}\n\nexport interface LocationOptions {\n  accuracy?: LocationAccuracy;\n  maximumAge?: number;\n  enableHighAccuracy?: boolean;\n  timeInterval?: number;\n  distanceInterval?: number;\n  timeout?: number;\n  mayShowUserSettingsDialog?: boolean;\n}\n\nexport interface LocationData {\n  coords: {\n    latitude: number;\n    longitude: number;\n    altitude: number;\n    accuracy: number;\n    heading: number;\n    speed: number;\n  };\n  timestamp: number;\n}\n\nexport interface HeadingData {\n  trueHeading: number;\n  magHeading: number;\n  accuracy: number;\n}\n\nexport interface GeocodedLocation {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n}\n\nexport interface Address {\n  city: string;\n  street: string;\n  region: string;\n  country: string;\n  postalCode: string;\n  name: string;\n}\n\nexport { PermissionStatus };\n\nexport type PermissionDetailsLocationIOS = {\n  scope: 'whenInUse' | 'always';\n};\n\nexport type PermissionDetailsLocationAndroid = {\n  scope: 'fine' | 'coarse' | 'none';\n};\n\nexport interface PermissionResponse extends UMPermissionResponse {\n  ios?: PermissionDetailsLocationIOS;\n  android?: PermissionDetailsLocationAndroid;\n}\n\nexport interface LocationTaskOptions {\n  accuracy?: LocationAccuracy;\n  timeInterval?: number; // Android only\n  distanceInterval?: number;\n  showsBackgroundLocationIndicator?: boolean; // iOS only\n  deferredUpdatesDistance?: number;\n  deferredUpdatesTimeout?: number;\n  deferredUpdatesInterval?: number;\n\n  // iOS only\n  activityType?: LocationActivityType;\n  pausesUpdatesAutomatically?: boolean;\n\n  foregroundService?: {\n    notificationTitle: string;\n    notificationBody: string;\n    notificationColor?: string;\n  };\n}\n\nexport interface LocationRegion {\n  identifier?: string;\n  latitude: number;\n  longitude: number;\n  radius: number;\n  notifyOnEnter?: boolean;\n  notifyOnExit?: boolean;\n}\n\ntype Subscription = {\n  remove: () => void;\n};\nexport type LocationCallback = (data: LocationData) => any;\nexport type LocationHeadingCallback = (data: HeadingData) => any;\n\nenum LocationAccuracy {\n  Lowest = 1,\n  Low = 2,\n  Balanced = 3,\n  High = 4,\n  Highest = 5,\n  BestForNavigation = 6,\n}\n\nenum LocationActivityType {\n  Other = 1,\n  AutomotiveNavigation = 2,\n  Fitness = 3,\n  OtherNavigation = 4,\n  Airborne = 5,\n}\n\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType };\n\nexport enum GeofencingEventType {\n  Enter = 1,\n  Exit = 2,\n}\n\nexport enum GeofencingRegionState {\n  Unknown = 0,\n  Inside = 1,\n  Outside = 2,\n}\n\nlet nextWatchId = 0;\nlet headingId;\nfunction _getNextWatchId() {\n  nextWatchId++;\n  return nextWatchId;\n}\nfunction _getCurrentWatchId() {\n  return nextWatchId;\n}\n\nlet watchCallbacks: {\n  [watchId: number]: LocationCallback | LocationHeadingCallback;\n} = {};\n\nlet deviceEventSubscription: Subscription | null;\nlet headingEventSub: Subscription | null;\nlet googleApiKey;\nconst googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\n\nexport async function getProviderStatusAsync(): Promise<ProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationData> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\nexport async function getLastKnownPositionAsync(): Promise<LocationData> {\n  return ExpoLocation.getLastKnownPositionAsync();\n}\n\n// Start Compass Module\n\n// To simplify, we will call watchHeadingAsync and wait for one update To ensure accuracy, we wait\n// for a couple of watch updates if the data has low accuracy\nexport async function getHeadingAsync(): Promise<HeadingData> {\n  return new Promise<HeadingData>(async (resolve, reject) => {\n    try {\n      // If there is already a compass active (would be a watch)\n      if (headingEventSub) {\n        let tries = 0;\n        const headingSub = LocationEventEmitter.addListener(\n          'Expo.headingChanged',\n          ({ heading }: { heading: HeadingData }) => {\n            if (heading.accuracy > 1 || tries > 5) {\n              resolve(heading);\n              LocationEventEmitter.removeSubscription(headingSub);\n            } else {\n              tries += 1;\n            }\n          }\n        );\n      } else {\n        let done = false;\n        let subscription;\n        let tries = 0;\n        subscription = await watchHeadingAsync((heading: HeadingData) => {\n          if (!done) {\n            if (heading.accuracy > 1 || tries > 5) {\n              subscription.remove();\n              resolve(heading);\n              done = true;\n            } else {\n              tries += 1;\n            }\n          } else {\n            subscription.remove();\n          }\n        });\n\n        if (done) {\n          subscription.remove();\n        }\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<{ remove: () => void }> {\n  // Check if there is already a compass event watch.\n  if (headingEventSub) {\n    _removeHeadingWatcher(headingId);\n  }\n\n  headingEventSub = LocationEventEmitter.addListener(\n    'Expo.headingChanged',\n    ({ watchId, heading }: { watchId: string; heading: HeadingData }) => {\n      const callback = watchCallbacks[watchId];\n      if (callback) {\n        callback(heading);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    }\n  );\n\n  headingId = _getNextWatchId();\n  watchCallbacks[headingId] = callback;\n  await ExpoLocation.watchDeviceHeading(headingId);\n  return {\n    remove() {\n      _removeHeadingWatcher(headingId);\n    },\n  };\n}\n\n// Removes the compass listener and sub from JS and Native\nfunction _removeHeadingWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  delete watchCallbacks[watchId];\n  ExpoLocation.removeWatchAsync(watchId);\n  if (headingEventSub) {\n    LocationEventEmitter.removeSubscription(headingEventSub);\n    headingEventSub = null;\n  }\n}\n// End Compass Module\n\nfunction _maybeInitializeEmitterSubscription() {\n  if (!deviceEventSubscription) {\n    deviceEventSubscription = LocationEventEmitter.addListener(\n      'Expo.locationChanged',\n      ({ watchId, location }: { watchId: string; location: LocationData }) => {\n        const callback = watchCallbacks[watchId];\n        if (callback) {\n          callback(location);\n        } else {\n          ExpoLocation.removeWatchAsync(watchId);\n        }\n      }\n    );\n  }\n}\n\nexport async function geocodeAsync(address: string): Promise<GeocodedLocation[]> {\n  return ExpoLocation.geocodeAsync(address).catch(error => {\n    const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n    if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n      if (!googleApiKey) {\n        throw new CodedError(\n          error.code,\n          `${error.message} Please set a Google API Key to use geocoding.`\n        );\n      }\n      return _googleGeocodeAsync(address);\n    }\n    throw error;\n  });\n}\n\nexport async function reverseGeocodeAsync(location: {\n  latitude: number;\n  longitude: number;\n}): Promise<Address[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location should be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  return ExpoLocation.reverseGeocodeAsync(location).catch(error => {\n    const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n    if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n      if (!googleApiKey) {\n        throw new CodedError(\n          error.code,\n          `${error.message} Please set a Google API Key to use geocoding.`\n        );\n      }\n      return _googleReverseGeocodeAsync(location);\n    }\n    throw error;\n  });\n}\n\nexport function setApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nasync function _googleGeocodeAsync(address: string): Promise<GeocodedLocation[]> {\n  const result = await fetch(`${googleApiUrl}?key=${googleApiKey}&address=${encodeURI(address)}`);\n  const resultObject = await result.json();\n\n  if (resultObject.status === 'ZERO_RESULTS') {\n    return [];\n  }\n\n  assertGeocodeResults(resultObject);\n\n  return resultObject.results.map(result => {\n    let location = result.geometry.location;\n    // TODO: This is missing a lot of props\n    return {\n      latitude: location.lat,\n      longitude: location.lng,\n    };\n  });\n}\n\nasync function _googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<Address[]> {\n  const result = await fetch(\n    `${googleApiUrl}?key=${googleApiKey}&latlng=${options.latitude},${options.longitude}`\n  );\n  const resultObject = await result.json();\n\n  if (resultObject.status === 'ZERO_RESULTS') {\n    return [];\n  }\n\n  assertGeocodeResults(resultObject);\n\n  return resultObject.results.map(result => {\n    const address: any = {};\n\n    result.address_components.forEach(component => {\n      if (component.types.includes('locality')) {\n        address.city = component.long_name;\n      } else if (component.types.includes('street_address')) {\n        address.street = component.long_name;\n      } else if (component.types.includes('administrative_area_level_1')) {\n        address.region = component.long_name;\n      } else if (component.types.includes('country')) {\n        address.country = component.long_name;\n      } else if (component.types.includes('postal_code')) {\n        address.postalCode = component.long_name;\n      } else if (component.types.includes('point_of_interest')) {\n        address.name = component.long_name;\n      }\n    });\n    return address as Address;\n  });\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n// Polyfill: navigator.geolocation.watchPosition\nfunction watchPosition(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback,\n  options: LocationOptions\n) {\n  _maybeInitializeEmitterSubscription();\n\n  const watchId = _getNextWatchId();\n  watchCallbacks[watchId] = success;\n\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch(err => {\n    _removeWatcher(watchId);\n    error({ watchId, message: err.message, code: err.code });\n  });\n\n  return watchId;\n}\n\nexport async function watchPositionAsync(options: LocationOptions, callback: LocationCallback) {\n  _maybeInitializeEmitterSubscription();\n\n  const watchId = _getNextWatchId();\n  watchCallbacks[watchId] = callback;\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      _removeWatcher(watchId);\n    },\n  };\n}\n\n// Polyfill: navigator.geolocation.clearWatch\nfunction clearWatch(watchId: number) {\n  _removeWatcher(watchId);\n}\n\nfunction _removeWatcher(watchId) {\n  // Do nothing if we have already removed the subscription\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n\n  ExpoLocation.removeWatchAsync(watchId);\n  delete watchCallbacks[watchId];\n  if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n    LocationEventEmitter.removeSubscription(deviceEventSubscription);\n    deviceEventSubscription = null;\n  }\n}\n\ntype GeoSuccessCallback = (data: LocationData) => void;\ntype GeoErrorCallback = (error: any) => void;\n\nfunction getCurrentPosition(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback = () => {},\n  options: LocationOptions = {}\n): void {\n  invariant(typeof success === 'function', 'Must provide a valid success callback.');\n\n  invariant(typeof options === 'object', 'options must be an object.');\n\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\n\n// This function exists to let us continue to return undefined from getCurrentPosition, while still\n// using async/await for the internal implementation of it\nasync function _getCurrentPositionAsyncWrapper(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback,\n  options: LocationOptions\n): Promise<any> {\n  try {\n    await ExpoLocation.requestPermissionsAsync();\n    const result = await getCurrentPositionAsync(options);\n    success(result);\n  } catch (e) {\n    error(e);\n  }\n}\n\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getPermissionsAsync();\n}\n\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// --- Location service\n\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\n\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport function installWebGeolocationPolyfill(): void {\n  if (Platform.OS !== 'web') {\n    // Polyfill navigator.geolocation for interop with the core react-native and web API approach to\n    // geolocation\n    // @ts-ignore\n    window.navigator.geolocation = {\n      getCurrentPosition,\n      watchPosition,\n      clearWatch,\n\n      // We don't polyfill stopObserving, this is an internal method that probably should not even exist\n      // in react-native docs\n      stopObserving: () => {},\n    };\n  }\n}\n\nexport {\n  // For internal purposes\n  LocationEventEmitter as EventEmitter,\n  _getCurrentWatchId,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}